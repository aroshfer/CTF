// server.js â€” Run: node server.js
const express = require('express');
const multer  = require('multer');
const FileType = require('file-type');
const fs = require('fs').promises;
const path = require('path');
const sharp = require('sharp');
const { exec } = require('child_process');

const UPLOAD_DIR = path.join(__dirname, 'uploads');
if (!require('fs').existsSync(UPLOAD_DIR)) require('fs').mkdirSync(UPLOAD_DIR);

const app = express();
app.use(express.static('public'));

// simple multer memory storage so we can inspect bytes
const storage = multer.memoryStorage();
const upload = multer({ storage });

const ALLOWED_EXT = new Set(['.png', '.jpg', '.jpeg', '.gif']);

function sanitizeFilename(name) {
  return name.replace(/[^a-zA-Z0-9._-]/g, '_');
}

// naive "danger" scanner
function suspiciousBytes(buffer) {
  const s = buffer.toString('utf8').toLowerCase();
  if (s.includes('<?php') || s.includes('<script') || s.includes('eval(')) return true;
  return false;
}

app.post('/upload', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) return res.status(400).send('no file');

    const origName = path.basename(req.file.originalname);
    const ext = path.extname(origName).toLowerCase();
    if (!ALLOWED_EXT.has(ext)) return res.status(400).send('bad extension');

    // check Content-Type header vs provided
    const headerType = (req.headers['content-type'] || '').toLowerCase();
    if (!headerType.includes('multipart/form-data')) return res.status(400).send('bad content type');

    // magic-bytes check
    const ft = await FileType.fromBuffer(req.file.buffer);
    if (!ft || !['image/png','image/jpeg','image/gif'].includes(ft.mime)) {
      return res.status(400).send('invalid file bytes');
    }

    // naive content scan
    if (suspiciousBytes(req.file.buffer)) return res.status(400).send('suspicious content');

    // sanitize and save temporary file
    const safeBase = sanitizeFilename(origName);
    const tmpPath = path.join(UPLOAD_DIR, safeBase + '.tmp');
    await fs.writeFile(tmpPath, req.file.buffer);

    // re-encode using sharp and save as webp with random name
    const outName = `${Date.now()}-${Math.random().toString(36).slice(2,8)}.webp`;
    const outPath = path.join(UPLOAD_DIR, outName);
    await sharp(tmpPath).webp().toFile(outPath);

    // remove tmp
    await fs.unlink(tmpPath);

    res.send({ ok: true, url: `/images/${outName}` });
  } catch (e) {
    console.error(e);
    res.status(500).send('server error');
  }
});

// Serve saved files statically
app.use('/images', express.static(UPLOAD_DIR));

// Admin conversion endpoint (legacy). Admin uses id to reconvert file to legacy tool.
// Intentionally vulnerable: uses unsanitized filename interpolation in shell exec
app.post('/admin/convert', express.urlencoded({ extended: false }), async (req, res) => {
  const file = req.body.file; // expects a filename like '1234-abcd.webp'
  if (!file) return res.status(400).send('no file');

  // check file exists (simple check)
  const fpath = path.join(UPLOAD_DIR, file);
  if (!require('fs').existsSync(fpath)) return res.status(404).send('file not found');

  // Dangerous shell call (intentional for CTF)
  const cmd = `cwebp "${fpath}" -o "${fpath}.converted.webp"`;
  exec(cmd, { timeout: 5000 }, (err, stdout, stderr) => {
    if (err) return res.status(500).send('convert failed');
    res.send('converted');
  });
});

app.listen(3000, () => console.log('listening on 3000'));
